                           __________________

                            LAB 08 QUESTIONS
                           __________________


- Name: Nick Holleran
- NetID: holle286

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete the
lab.


PROBLEM 1 `sleep_print.c'
=========================

A
~

  Compile `sleep_print.c' using the provided `Makefile' which compiles
  it to `sleep_print'.  Run the program as
  ,----
  | ./sleep_print 1 "hello"
  `----
  After a few seconds, press Ctrl-C to send an interrupt signal.  Paste
  the results of your run below.

1 : hello  2 : hello  3 : hello  4 : hello  5 : hello ^Csleep_print: signaled, setting flag
 6 : hello sleep_print: finishing


B
~

  Examine the code for `sleep_print.c' and note the use of the
  `sigaction()' function to set up signal handlers. Inspect the signal
  handler function and describe how the signal handler causes the
  `sleep_print' to shut down in the space below.

It sets the global signal variable to 1, to show that the signal has been received, so the moment that the signal is no longer received, it goes back to the value 0


PROBLEM 2 `read_AB.c'
=====================

  Note that `read_AB.c' uses the same techniques as `sleep_print.c' to
  set up signal handlers and shut down on receiving a signal.

A
~

  Compile `read_AB.c' and run it. Paste the results of running it for a
  few seconds below.  Use Ctl-C to send an interrupt to end the program.

read_AB: listening for children
A had: | 1 : AAAA |
B had: | 1 : BBBB |
A had: | 2 : AAAA |
B had: | 2 : BBBB |
A had: | 3 : AAAA  4 : AAAA  5 : AAAA |
B had: | 3 : BBBB |
A had: | 6 : AAAA  7 : AAAA  8 : AAAA |
^Csleep_print: signaled, setting flag
sleep_print: finishing
read_AB: signaled, setting flag
B had: | 4 : BBBB |
read_AB: finishing
sleep_print: signaled, setting flag
sleep_print: signaled, setting flag
sleep_print: finishing


B
~

  Examine the code for `read_AB.c' and note where `pipe(), fork(),
  dup2()' are used to set up a communication channel for two children
  referred to as A and B. Note that these two children both run
  `sleep_print' but A has a 1 second delay while B has a 3 second delay.
  Note the main `while()' of `read_AB' which repeatedly reads from the
  pipes of its children.

  In the space below explain why the output for the program has the
  ordering that it does despite A producing A at a faster rate (every 1
  second) than B (every 3 seconds).


The read calls for pipeA and pipeB are incremental, meaning pipeA is called then pipeB is called so the output for pipA might be ready before pipeB, but the call to read pipeB happens before pipeA can be read a second time.

C
~

  In the output for `read_AB' there should be some lines for Child A
  that look like
  ,----
  | A had: | 1 : AAAA |
  `----
  but also some lines that look like
  ,----
  | A had: | 4 : AAAA  5 : AAAA |
  `----
  and
  ,----
  | A had: |15 : AAAA 16 : AAAA 17 : AAAA |
  `----
  while Child B lines always look like
  ,----
  | B had: | 4 : BBBB |
  `----
  Explain why there is variance in Child A lines while Child B lines
  look the same.

pipeA happens three times as fast, so eventually the pipe gets filled with the pipeA outputs and the read call just reads whatever is in the pipe. pipeB does not fill up with output as it gets called after every pipeA read which happens every second while pipeB every 3 seconds. PipeA repeats once and twice before it gets to three calls because it hasn't been blocked for as long yet. Eventually the pipe will be blocked for the full three seconds it takes for pipeB to give one output, so A will have three outputs since its 3 times as fast.


PROBLEM 3 `select_AB.c'
=======================

  Note that `select_AB.c' uses the same techniques as `sleep_print.c' to
  set up signal handlers and shut down on receiving a signal.


A
~

  Compile `select_AB.c' and run it. Paste the results of running it for
  a few seconds below.  Use Ctl-C to send an interrupt to end the
  program.

select_AB: listening for children
A had: | 1 : AAAA |
A had: | 2 : AAAA |
B had: | 1 : BBBB |
A had: | 3 : AAAA |
A had: | 4 : AAAA |
A had: | 5 : AAAA |
B had: | 2 : BBBB |
A had: | 6 : AAAA |
A had: | 7 : AAAA |
A had: | 8 : AAAA |
B had: | 3 : BBBB |
A had: | 9 : AAAA |
A had: |10 : AAAA |
A had: |11 : AAAA |
B had: | 4 : BBBB |
A had: |12 : AAAA |
^Csleep_print: signaled, setting flag
select_AB: signaled, setting flag
sleep_print: finishing
sleep_print: signaled, setting flag
sleep_print: finishing
A had: |13 : AAAA |
B had: | 5 : BBBB |
select_AB: finishing


B
~

  Examine the code for `select_AB.c'. Like `read_AB', it uses `pipe(),
  fork(), dup2()' to set up a communication channel for two children, A
  and B, which run `sleep_print' at differing rates.  However, the main
  `while()' of `select_AB' uses the `select()' system call to sleep
  until output is available from a child.

  In the space below explain why the output for the `select_AB' has the
  ordering that it does and why it differs from `read_AB'.

The select call makes it so that the function will sleep until there is something in a pipe. When something is in a pipe, it gets read. This means that pipeA no longer gets backed up with output since whenever the pipe receives an output it runs. Since A happens 3 times as fast as B, we see A happen 3 times as much.

C
~

  Part of the setup for the `select()' system call manipulates an
  `fd_set' data type using calls like `FD_ZERO'.  Do some research such
  as reading the manual pages to determine how this type works.

  Also explain how one can determine which children of A and B has input
  available after the `select()' call returns.

fd_set controls what happens to the file descriptor. FD_ZERO clears a set, while there are other system calls FD_ISSET, FD_SET, FD_CLEAR.

Using the FD_ISSET call will help determine which fd is part of the set, so one can determine if the A child is the set or the B child is the set.

D
~

  The output for `read_AB' contained mixed lengths for child A output as
  in
  ,----
  | A had: | 1 : AAAA |
  | A had: | 4 : AAAA  5 : AAAA |
  | A had: |15 : AAAA 16 : AAAA 17 : AAAA |
  `----

  Explain why the output for `select_AB' does not have such differences.

Similar to how I explained it in part B, the select call makes the program wait until either pipe has had something written into it, then runs when either pipe has been changed. This means that the pipeA cannot get filled up like it does in read_AB since the read call is called everytime a new output is added to the pipe.
