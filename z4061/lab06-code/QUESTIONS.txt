                           __________________

                            LAB 06 QUESTIONS
                           __________________


- Name: Nick Holleran
- NetID: holle286

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete the
lab.


PROBLEM 1: Binary File Format w/ Read
=====================================

A
~

  Compile all programs in the lab code directory with the provided
  `Makefile'.  Run the command
  ,----
  | ./make_dept_directory cse_depts.dat
  `----
  to create the `cse_depts.dat' binary file. Examine the source code for
  this program the header `department.h'. Explain the format of the
  binary file `cse_depts.dat'.
  - What system calls are used in `make_dept_directory.c' to create this
    file?

open, and write and close
  - How is the `sizeof()' operator used to simplify some of the
    computations in `make_dept_directory.c'?
uses sizeof to find the size in bytes of the arrays/structs to create offsets easily
  - What data is in `cse_depts.dat' and how is it ordered?

The different departments names and emails, ordered cs, ee, then it


B
~

  Run the `print_department_read' program which takes a binary data file
  and a department code to print.  Show a few examples of running this
  program with the valid command line arguments. Include in your demo
  runs that
  - Use the `cse_depts.dat' with known and unknown department codes

Dept Name: CS Offset: 104
Dept Name: EE Offset: 2152
Dept Name: IT Offset: 3688

8 Contacts for CS department
Arindam Banerjee <baner029@umn.edu>
Daniel Boley <boley@umn.edu>
Abhishek Chandra <chandra@umn.edu>
David Hung-Chang Du <du@umn.edu>
Maria Gini <gini@umn.edu>
Stephen Guy <sjguy@umn.edu>
Tian He <tianhe@umn.edu>
Mats Heimdahl <heimdahl@umn.edu>


Dept Name: CS Offset: 104
Dept Name: EE Offset: 2152
Dept Name: IT Offset: 3688
Department code 'ME' not found

  - Use a file other than `cse_depts.dat'

'QUESTIONS.txt' does not appear to be a binary department directory file


C
~

  Study the source code for `print_department_read' and describe how it
  initially prints the table of offsets shown below.
  ,----
  | Dept Name: CS Offset: 104
  | Dept Name: EE Offset: 2152
  | Dept Name: IT Offset: 3688
  `----
  What specific sequence of calls leads to this information?

A read call into the file called in the argument, and the department name and offset is stored in the dept object


D
~

  What system call is used to skip immediately to the location in the
  file where desired contacts are located? What arguments does this
  system call take? Consult the manual entry for this function to find
  out how else it can be used.

lseek(fd, offset, method)

Uses the file descpritor and offsets given the offset value, uses the method to determine how the offset should be interpreted


PROBLEM 2: mmap() and binary files
==================================

  An alternative to using standard I/O functions is "memory mapped"
  files through the system call `mmap()'. The program
  `print_department_mmap.c' provides the functionality as the previous
  `print_department_read.c' but uses a different mechanism.


(A)
~~~

  Early in `print_department_mmap.c' an `open()' call is used as in the
  previous program but it is followed shortly by a call to `mmap()' in
  the lines
  ,----
  |   char *file_bytes =
  |     mmap(NULL, size, PROT_READ, MAP_SHARED,
  |          fd, 0);
  `----
  Look up reference documentation on `mmap()' and describe some of the
  arguments to it including the `NULL' and `size' arguments. Also
  describe its return value.

void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);

NULL is the starting address on where to begin the map, while size is the length of the mapping, while fd is the file descriptior and offset is the size of the offset, prot and flags ar different methods for the function.

mmap returns a pointer to the mapped area on success, otherwise the MAP_FAILED value is returned

(B)
~~~

  The initial setup of the program uses `mmap()' to assign a pointer to
  variable `char *file_bytes'.  This pointer will refer directly to the
  bytes of the binary file.

  Examine the lines
  ,----
  |   ////////////////////////////////////////////////////////////////////////////////
  |   // CHECK the file_header_t struct for integrity, size of department array
  |   file_header_t *header = (file_header_t *) file_bytes; // binary header struct is first thing in the file
  `----

  Explain what is happening here: what value will the variable `header'
  get and how is it used in subsequent lines.

header will take the size in bytes of the object file_header_t times the number of bytes in the binary file currently, and the object will be assigned different variables in its ident variable array, as well as the number of departments in dep_nums.

(C)
~~~

  After finishing with the file header, the next section of the program
  begins with the following.
  ,----
  |   ////////////////////////////////////////////////////////////////////////////////
  |   // SEARCH the array of department offsets for the department named
  |   // on the command line
  | 
  |   dept_offset_t *offsets =           // after file header, array of dept_offset_t structures
  |     (dept_offset_t *) (file_bytes + sizeof(file_header_t));
  | 
  `----

  Explain what value the `offsets_arr' variable is assigned and how it
  is used in the remainder of the SEARCH section.

The offsets arr will be assigned the size of the dept_offset_t pointer times the size of the binary file in bytes + the sizeof the header to offset where the offset_arr goes  in the file.

The offset will then hold the number of bytes needed to offset for each new department in the file


(D)
~~~

  The final phase of the program begins below
  ,----
  |   ////////////////////////////////////////////////////////////////////////////////
  |   // PRINT out all personnel in the specified department
  |   ...
  |   contact_t *dept_contacts = (contact_t *) (file_bytes + offset);
  `----
  Describe what value `dept_contacts' is assigned and how the final
  phase uses it.

The dept_contacts is assigned the space in the file in bytes of where to put the contacts information based on the offset, the size of the file in bytes, and the size of the contact_t

When iterated through the contact portion of the file the contact.name and contact.email is assigned values as the file is read and is printed.
