                           __________________

                            LAB 12 QUESTIONS
                           __________________


- Name: Nick Holleran
- NetID: holle286

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete Lab01.


PROBLEM 1: Spell Checking Busily
================================

A
~

  Examine the file `check_spelling_busy.c' which performs the simple
  task of spell checking words that are typed into the terminal using
  pthreads.  Compile this program with the provided `Makefile' and run
  it showing your results below.

Enter words to check spelling, Ctrl-d to end input
check
'check' ok
spel
'spel' INCORRECT
busy
'busy' ok



B
~

  Examine the source code for `check_spelling_busy.c' and describe the
  basic architecture of how input is accepted and spell checking is
  done.  Describe what data structure is used to coordinate reading and
  checking the spelling of words. How is access to this data structure
  controlled so that the threads to not corrupt it.

The data structure used is a queue. Input is scanned into a char array, then it nests another loop and inside the loop one thread locks and checks if space is still available in the queue, if it isn't unlock and loop, if it is break out of the loop. The outside loop then runs repeatedly as the queue increments through the char array and adds each element into the queue, and then unlocks the lock started in the nested loop. Access to the queue is controlled with locking and unlocking the thread to make sure that nothing messes with it while it is being added to, and unlocking when everthing is finished.



C
~

  Identify what conditions are required for each of the thread types to
  make progress: what must be true about the shared data structure in
  order for them to proceed? How are these conditions checked?

Each thread locks and only unlocks when something needs to be added to the queue (when reading) or when finished reading. In the check words, it works in the reverse where it will lock when it checks to see if the thread is empty, and if it isn't it will unlock and another thread will check, if it is empty it will unlock and break the loop. These condition rely on adding and subtracting things to the queue until the conditions are met.


D
~

  Time the following run of `check_spelling_busy'.
  1. Start the program via `time ./check_spelling_busy'
  2. Type the word 'hello' and press enter
  3. Type Ctrl-d to end input

  Report your timing for this run below which should appear somewhat
  strange.  Attempt to explain this strange behavior based on your
  observations of thread behavior above.

real	0m1.551s
user	0m1.550s
sys	0m0.001s



The system uses the threads to check constantly when the input is used, and as soon as its entered, it goes into the queue and then is checked very quickly. Most of the time is put on the user for entering the input.

PROBLEM 2: Spell Checking Efficiently
=====================================

A
~

  Examine the code for `check_spelling_condvar.c' which introduces
  Pthread Condition Variables.  First, run the same experiment and
  compare the timing to this new version:

  1. Start the program via `time ./check_spelling_condvar'
  2. Type the word 'hello' and press enter
  3. Type Ctrl-d to end input


real	0m1.707s
user	0m0.012s
sys	0m0.005s


B
~

  Much of the code between `check_spelling_busy' and
  `check_spelling_condvar' is identical. An important difference is in
  the portion where threads determine whether the conditions to proceed
  have been met.

  Examine closely the sections of code that `check_spelling_condvar.c'
  use to determine when the reader thread can add something to the queue
  and when checker thread has a word to check. Describe these
  changes. Research the new functions that are used and briefly describe
  them.

Instead of locking inside the nested while loop it locks at the start of the first while loop, and when the queue is not full (or not empty if in check_words), instead of unlocking it waits until a notifaction from another thread is given, and then continues. After that the queue is changed, then unlocked and then the notifcation is sent out after that.

pthread_cond_wait() will make a blocking call until the required condition is met

pthread_cond_broadcast unblocks all blocked calls on that condition




C
~

  What function call do the two threads use to communicate that the
  'condition' of the queue has changed? What affect does this function
  have on the other thread?

pthread_cond_wait and cond_broadcast. The wait call will block one thread, and then wait until the required condition is unblocked, and broadcast will unblock all threads that are currently blocked by that condition.


D
~

  This spell checking code is an instance of the classic
  producer/consumer coordination problem where two different types of
  threads/processes exist: one producing data (the reader in this case)
  and the other consuming it (the spell checker in this case).  When
  these threads can only proceed under different conditions, condition
  variables make their coordination more efficient than would be
  possible based on locks (mutexes) alone.

  Benchmark the efficiency of spell-checking 100 words using the
  following commands to compare the two variations. Show your code below
  and describe the timing differences.

  ,----
  | > time tail -100 english-dict.txt | ./check_spelling_busy > /dev/null
  | ...
  | 
  | > time tail -100 english-dict.txt | ./check_spelling_condvar > /dev/null
  | ...


check_spelling_busy:

real	0m2.150s
user	0m4.176s
sys	0m0.045s


check_spelling_condvar:

real	0m1.255s
user	0m1.222s
sys	0m0.037s


The condvar time is significantly faster than the busy time in each the real user and sys times. This is because busy code locks and unlocks the threads constantly which slow the runtime, while condvar uses blocking calls and runs as soon as each condition is met.

  `----
